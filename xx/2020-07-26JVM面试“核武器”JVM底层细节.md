## 什么是三色标记？

黑色：根对象，或者该对象与它的子对象都被扫描过。 

灰色：对本身被扫描，但是还没扫描完该对象的子对象。 

白色：未被扫描对象，如果扫描完所有对象之后，最终为白色的为不可达对象，既垃圾对象。

## 为什么用三色标记？

在三色标记法之前有一个算法叫 Mark-And-Sweep（标记清除）。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是 0，如果 发现对象是可达的就会置为 1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未被标记的对象统一清理，再次把所有的标记位 设置成 0 方便下次清理。

这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步进行 GC 操作。因为在不同阶段标记清扫法的标志位 0 和 1 有不同的含义， 那么新增的对象无论标记为什么都有可能意外删除这个对象。对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需 要一个算法来解决 GC 运行时程序长时间挂起的问题，那就三色标记法。 

三色标记最大的好处是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个 GC。 

三色标记法很简单。首先将对象用三种颜色表示，分别是白色、灰色和黑色。 

## 三色标记会产生什么问题？

GC 并发情况下的漏标问题

## 漏标问题如何解决？

CMS：IncrementalUpdate 算法 ，重新标记

G1：SATB(snapshot-at-the-beginning) 快照

## 什么是跨代引用？

堆空间通常被划分为新生代和老年代。由于新生代的垃圾收集通常很频繁，如果老年代对象引用了新生代的对象，那么回收新生代的话，需要跟踪从老 年代到新生代的所有引用，所以要避免每次 YGC 时扫描整个老年代，减少开销。

## 什么是卡表和记忆集？

卡表：

由于做新生代 GC 时，需要扫描整个 OLD 区，效率非常低，所以 JVM 设计了 CardTable,如果一个 OLD 区 CardTable 中有对象指向 Y 区， 就将它设为 Dirty （标志位 1）, 下次扫描时，只需要扫描 CARDTABLE 上是 Dirty 的内存区域即可。 

字节数组 CARDTABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”(CardPage)。 一般来说，卡页大小 都是以 2 的 N 次幂的字节数，假设使用的卡页是 2 的 10 次幂，即 1K,内存区域的起始地址是 0x0000 的话，数组 CARD_TABLE 的第 0、1、2 号元素，分别 对应了地址范围为 0x0000~0x03FF、0x0400~0x07FF、0x0800~0x011FF 的卡页内存.



记忆集：

记录了其他 Region 中的对象到本 Region 的引用, 

RSet 的价值在于使得垃圾收集器不需要扫描整个堆,找到谁引用了当前分区中的对象，只需要扫描 RSet 即可。

 RSet 本身就是一个 Hash 表，如果是在 G1 的话，则是在一个 Region 区里面。

## 什么是安全点和安全区域？

安全点

用户线程暂停，GC 线程要开始工作，但是要确保用户线程暂停的这行字节码指令是不会导致引用关系的变化。所以 JVM 会在字节码指令中，选一些指令， 作为“安全点”，比如方法调用、循环跳转、异常跳转等，一般是这些指令才会产生安全点。 

为什么它叫安全点，是这样的，GC 时要暂停业务线程，并不是抢占式中断（立马把业务线程中断）而是主动是中断。 

主动式中断是设置一个标志，这个标志是中断标志，各业务线程在运行过程中会不停的主动去轮询这个标志，一旦发现中断标志为 True,就会在自己最近 的“安全点”上主动中断挂起。



安全区域

安全区域是指能够确保在某一段代码片段之中， 引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区 城看作被扩展拉伸了的安全点。



当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，这段时间里 JVM 要发起 GC 就不必去管这个线程了。 当线程要离开安全区域时，它要 JVM 是否已经完成了（根节点枚举，或者其他 GC 中需要暂停用户线程的阶段) 

1、如果完成了，那线程就当作没事发生过，继续执行。

 2、否则它就必须一直等待， 直到收到可以离开安全区域的信号为止。

## 为什么需要安全区域？

要是业务线程都不执行（业务线程处于 Sleep 或者是 Blocked 状态），那么程序就没办法进入安全点，对于这种情况，就必须引入安全区域

## 垃圾回收器三项指标是什么？

内存占用、吞吐量、延时 

## GC日志详解？

YGC GC原因 年轻代 回收前年轻代空间 回收后年轻代空间 年轻代总大小 回收前堆占用空间 回收后堆占用空间

用户time 内核time 总计time



